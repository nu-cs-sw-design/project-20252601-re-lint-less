@startuml

package BytecodeParser {

  interface IClassParser {
    + parse(className: String): IClass
  }

  interface IClass {
    + getClassName(): String
    + getMethods(): List<IMethod>
    + getFields(): List<IField>
    + getDirectInterfaces(): List<String>
    + getSuperClassName(): String
  }

  interface IMethod {
    + getName(): String
    + getParameterCount(): int
    + getOpcodes(): List<Integer>
    + getInstructions(): List<IInstruction>
    + getLocalVariables(): List<ILocalVariable>
    + getDescriptor(): String
    + isStatic(): boolean
  }

  interface IField {
    + getName(): String
    + isStatic(): boolean
    + isFinal(): boolean
  }

  interface IInstruction {
    + getOpcode(): int
    + getJumpLabel(): ILabel
    + isPushConstant(): boolean
    + getConstantValue(): Number
    + getVarIndex(): Integer
  }

  interface ILabel {
  }

  interface ILocalVariable {
    + getName(): String
    + getIndex(): int
  }

  class Parser {
    - parser: IClassParser
    + Parser(parser: IClassParser)
    + parse(className: String): IClass
  }
}

package "BytecodeParser.ASM" {

  class  ASMParser {
    + parse(className: String): IClass
  }

  class ASMClass {
    -{final} node: ClassNode
    + ASMClass(node: ClassNode)
    + getClassName(): String
    + getMethods(): List<IMethod>
    + getFields(): List<IField>
    + getDirectInterfaces(): List<String>
    + getSuperClassName(): String
  }

  class ASMMethod {
    -{final} node: MethodNode
    + ASMMethod(node: MethodNode)
    + getName(): String
    + getParameterCount(): int
    + getOpcodes(): List<Integer>
    + getInstructions(): List<IInstruction>
    + getLocalVariables(): List<ILocalVariable>
    + getDescriptor(): String
    + isStatic(): boolean
  }

  class ASMField  {
    -{final} node: FieldNode
    + ASMField(node: FieldNode)
    + getName(): String
    + getType(): String
    + isStatic(): boolean
    + isFinal(): boolean
  }

  class ASMInstruction {
    -{final} insn: AbstractInsnNode
    + ASMInstruction(insn: AbstractInsnNode)
    + getOpcode(): int
    + getJumpLabel(): ILabel
    + isPushConstant(): boolean
    + getConstantValue(): Number
    + getVarIndex(): Integer
  }

  class ASMLabel {
    +{final} node: LabelNode

    + equals(Object o): Boolean
    + hashCode(): int
  }

  class ASMLocalVariable  {
    -{final} node: LocalVariableNode
    + ASMLocalVariable(node: LocalVariableNode)
    + getName(): String
    + getIndex(): int
  }

}

package "ClassFinder " {

  interface ClassFinder {
    + discoverClasses(inputs: String[]): List<String>
  }

  class FileSystemClassFinder  {
    -{final} classesRoot: Path
    + FileSystemClassFinder(classesRoot: Path)
    + discoverClasses(inputs: String[]): List<String>
    - findClassFilesInDirectory(dir: Path): List<String>
    - findClassFilesByPattern(pattern: String): List<String>
    - pathToClassName(classPath: Path): String
  }
}

package Reporting {

  interface Reporter {
    + report(className: String, message: String): void
  }

  class ConsoleReporter {
    + ConsoleReporter()
    + report(className: String, message: String): void
  }
}

package Checks {

  interface Check {
    + apply(clazz: IClass, reporter: Reporter): boolean
  }

  class MagicNumberCheck {
    -{final}{static} ALLOWED: Set<Number>

    + apply(clazz: IClass, reporter: Reporter): boolean

    - isAllowed(Number n): boolean
    - decodeConstant(IInstruction insn): Number
  }

  class NamingConventionCheck {
    + apply(clazz: IClass, reporter: Reporter): boolean

    - checkClassName(IClass classNode, Reporter reporter): void
    - checkMethodNames(IClass classNode, Reporter reporter): void
    - checkFieldNames(IClass classNode, Reporter reporter): void
    - isPascalCase(String name): boolean
    - isCamelCase(String name): boolean
    - isUpperSnakeCase(String name): boolean
  }

  class PublicFieldCheck {
    + apply(clazz: IClass, reporter: Reporter): boolean
  }

  class RedundantInterfacesCheck {
    -{final} IClassParser: classParser

    + RedundantInterfacesCheck(parser: Parser)

    + apply(clazz: IClass, reporter: Reporter): boolean

    - collectAllInterfacesFromClass(className: String, out: Set<String>, visited: Set<String>): void
    - collectSuperInterfaces(ifaceName: String, out: Set<String>, visited: Set<String>): void
  }

  class GodClassCheck {
    -{final}{static} MAX_FIELDS: int
    -{final}{static} MAX_METHODS: int

    + apply(clazz: IClass, reporter: Reporter): boolean
  }

  class TooManyNestedIfsCheck {
    -{final}{static} MAX_NESTING: int

    + apply(clazz: IClass, reporter: Reporter): boolean

    - computeMaxIfNesting(IMethod method): int
    - isConditionalJump(IInstruction insn): boolean
    - findLabelIndex(List<IInstruction> instructions, ILabel targetLabel): int
  }

  class TooManyParametersCheck {
    -{final}{static} MAX_PARAMS: int

    + apply(clazz: IClass, reporter: Reporter): boolean
  }

  class UnusedVariablesCheck {
    + apply(clazz: IClass, reporter: Reporter): boolean

    - checkForUnusedVariables(String className, IMethod method, Reporter reporter): void
    - isLoadInstruction(int opcode): boolean
    - isMethodParameter(IMethod method, ILocalVariable localVar): boolean
    - countParameterSlots(String paramDescriptor): int
  }

  class EmptyMethodCheck {
    + apply(clazz: IClass, reporter: Reporter): boolean

    - isOnlyReturn(instructions: List<IInstruction>): boolean
  }

  class CheckFactory {
    -{final}{static} asmParser: IClassParser
    +{static} createChecks(): List<Check>
  }

}

class Linter {
  -{final} parser: Parser
  -{final} checks: List<Check>

  + Linter(parser: Parser, initialChecks: List<Check>)

  - run(className: String, reporter: Reporter): void
  ~ runMultiple(classNames: List<String>, reporter: Reporter): void
}

class main {
  -{final}{static} CLASSES_ROOT

  +{static} main(args: String[]): void
}

IClassParser     <|.. ASMParser
IClass           <|.. ASMClass
IMethod          <|.. ASMMethod
IField           <|.. ASMField
IInstruction     <|.. ASMInstruction
ILabel           <|.. ASMLabel
ILocalVariable   <|.. ASMLocalVariable

ClassFinder      <|.. FileSystemClassFinder
Reporter         <|.. ConsoleReporter
Check            <|.. MagicNumberCheck
Check            <|.. NamingConventionCheck
Check            <|.. PublicFieldCheck
Check            <|.. RedundantInterfacesCheck
Check            <|.. GodClassCheck
Check            <|.. TooManyNestedIfsCheck
Check            <|.. TooManyParametersCheck
Check            <|.. UnusedVariablesCheck
Check            <|.. EmptyMethodCheck

Parser --> IClassParser
Parser --> IClass
Linter --> Parser
Linter --> Check
Linter --> Reporter
Linter --> IClass

MagicNumberCheck --> IMethod
MagicNumberCheck --> IInstruction

NamingConventionCheck --> IMethod
NamingConventionCheck --> IField

PublicFieldCheck --> IField

RedundantInterfacesCheck --> IClassParser

GodClassCheck --> IMethod
GodClassCheck --> IField

TooManyNestedIfsCheck --> IMethod
TooManyNestedIfsCheck --> IInstruction
TooManyNestedIfsCheck --> ILabel

TooManyParametersCheck --> IMethod

UnusedVariablesCheck --> IMethod
UnusedVariablesCheck --> ILocalVariable
UnusedVariablesCheck --> IInstruction

EmptyMethodCheck --> IMethod
EmptyMethodCheck --> IInstruction

CheckFactory --> Check
CheckFactory --> IClassParser

main --> Linter
main --> Parser
main --> CheckFactory
main --> ClassFinder
main --> Reporter

@enduml
